<!DOCTYPE html>
<html lang="en">

<head>
    <title>Zenon Page Templates (ZPT-JS): User's guide</title>
    <meta charset="UTF-8">
    <style>
        body {
            background-color: white;
            font-size: 1em;
            color: black;
            font-family: arial, helvetica, verdana;
        }
        
        h1 {
            font-weight: bold;
        }
        
        h2 {
            font-weight: bold;
        }
        
        h3 {
            font-weight: bold;
        }
        
        h4 {
            font-weight: bold;
        }
        
        table,
        th,
        td {
            border: 1px solid black;
        }
        
        .sub {
            font-size: .75em;
        }
        
        code {
            color: red;
        }
        
        pre {
            background-color: black;
            color: white;
            padding-top: 1em;
            padding-left: 4em;
        }
    </style>
</head>

<body>
    <a id="top"></a>
    <h1>Zenon Page Templates (ZPT-JS): User's guide</h1>
    <div class="sub">last modified: 2016/15/11</div>
    <div class="sub">author <a href="mailto:david.javapagetemplates@gmail.com">David Cana</a></div>
    <div class="sub">contributed by <a href="mailto:david.javapagetemplates@gmail.com">David Cana</a></div>

    <a id="zpt"></a>
    <h2>Zope Page Templates</h2>
    <p>
        ZPT-JS is a Javascript implementation of Zope Page Templates (ZPT). Because ZPT-JS isn't running in the context of Zope and isn't written with Python, there are necessarily some differences between ZPT-JS and ZPT. This document will concentrate on the ways that ZPT-JS differs from ZPT. For an introduction to ZPT refer to the chapter
        <a href="http://docs.zope.org/zope2/zope2book/ZPT.html">Using
      Zope Page Templates</a> in the
        <a href="http://docs.zope.org/zope2/zope2book/">Zope Book</a>. For a complete reference to ZPT, refer to the
        <a href="http://docs.zope.org/zope2/zope2book/AppendixC.html">ZPT Reference</a>.
    </p>
    
    <a id="firstSteps"></a>
    <h2>First steps using ZPT-JS</h2>
    
    <p>
        How can we use ZPT-JS? The <code>dictionary</code> is used to define global variables.
    </p>
    <p>
        An example of invoking ZPT-JS using CommonJS in a browser environment:
    </p>
    
    <strong>sample.js</strong>
    <pre>
"use strict";

var zpt = require( 'zpt' );

var dictionary = { 
    aString: "string",
    doggy: false,
    number1: 1,
    number100: 100,
    user: {
        name: "Bob", 
        age: function( ){
            return 25;
        }
    },
    items: [ 'item0', 'item1', 'item2' ]
};
    
zpt.run({
    root: document.body,
    dictionary: dictionary
});
    </pre>
    <p>
        Then browserify that file to build the final js file. And the html file is:
    </p>
    
    <strong>sample.html</strong>
    <pre>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;Some ZPT-JS examples&lt;/title&gt;
        
        &lt;script src="sample.js" defer&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Some expressions&lt;/h1&gt;
        &lt;ol&gt;
            &lt;li data-tcontent="user/name"&gt;xxx&lt;/li&gt;
            &lt;li data-tcontent="string:help my ${user/name}"&gt;xxx&lt;/li&gt;
            &lt;li data-tcontent="doggy"&gt;not false&lt;/li&gt;
            &lt;li data-tcontent="not:doggy"&gt;not false&lt;/li&gt;
            &lt;li data-tcontent="eq: number1 number100"&gt;not true&lt;/li&gt;
            &lt;li data-tcontent="user/name | string:no friends"&gt;any friends?&lt;/li&gt;
            &lt;li data-tcontent="user2/name | string:no friends"&gt;any friends?&lt;/li&gt;
            &lt;li data-tcontent="items[0]"&gt;an item&lt;/li&gt;
            &lt;li data-tcontent="user/age()"&gt;user/age()&lt;/li&gt;
        &lt;/ol&gt;
    &lt;/body&gt;
&lt;/html&gt;
    </pre>
    <p>
        The invokation of ZPT-JS is at:
    </p>
    <pre>
zpt.run({
    root: document.body,
    dictionary: dictionary
});
    </pre>
    <p>
        The first argument sets the DOM node where ZPT-JS will search its custom HTML tags: it can be a string or an array of them. The second one is the dictionary, a Javascript object that will be available to all custom HTML tags of ZPT-JS. You can also run ZPT-JS as a Jquery plugin:
    </p>
    <pre>
"use strict";

var $ = require( 'jquery' );
require( '../../../js/app/jqueryPlugin.js' );

var dictionary = { ... }; // Your dictionary entries

$( 'body' ).zpt({
    dictionary: dictionary
});
    </pre>
    
    <p>
        If we don't use external macros ZPT-JS executes synchronously: no external file needs to be loaded. But if we use at least one external macro ZPT-JS needs to load one or more external files using HTTP. This makes ZPT-JS code executes asynchronously. Keep in mind this! An alternative method to deal with this is to call ZPT-JS like this:
    </p>
    <pre>
var zptParser = zpt.buildParser({
    root: document.body,
    dictionary: dictionary,
    declaredRemotePageUrls: [ 'externalMacros-definitions2.html', 'externalMacros-definitions3.html' ]
});

zptParser.init(
    function(){
        zptParser.run();
        [ your code here ]
    }
);
    </pre>
    
    <p>That's OK. But... how can we use ZPT-JS at the server side (using node.js)? node-jsdom is needed when no browser is available:</p>
    <pre>
"use strict";

var jsdom = require( 'node-jsdom' ).jsdom;

jsdom.env(
    '&lt;!doctype html&gt;'
	+ '&lt;html&gt;'
	+ '&lt;body&gt;&lt;h1 id="t1" data-tcontent="string:hello"&gt;a text&lt;/h1&gt;&lt;/body&gt;'
	+ '&lt;/html&gt;', 
    [ 'http://code.jquery.com/jquery.min.js' ], 
    function( err, window ) {
        
        // Check if an error occurs
        if ( err ) {
            console.error( err );
            return 1;
        }

        // Copy window to global
        global.window = window;
        
        // Copy from window to local vars
        var $ = window.$;
        var document = window.document;

        // Parse template
        var zpt = require( 'zpt' );
        
        zpt.run({
            root: document.body,
            dictionary: {}
        });
        
        console.log( 'Done!' );
    }
);
    </pre>
    
    <p>
        Take a look at <a href="https://www.npmjs.com/package/node-jsdom">jsdom docs</a> for more info about jsdom.
    </p>
    
    <a id="tags"></a>
    
    <a id="tags.zpt-js"></a>
    <h3>ZPT-JS tags</h3>
    <p>
        The name of tags are not the same because if they were the resulting HTML douments will not be well formed. The list of tags with their equivalences are:
    </p>
    <table>
        <tr>
            <th>ZPT tag name</th>
            <th>ZPT-JS tag name</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>metal:define-macro</td>
            <td>data-mdefine-macro</td>
            <td>Defines a macro</td>
        </tr>
        <tr>
            <td>metal:define-slot</td>
            <td>data-mdefine-slot</td>
            <td>Defines a slot to make possible to fill it later</td>
        </tr>
        <tr>
            <td>metal:fill-slot</td>
            <td>data-mfill-slot</td>
            <td>Fills a slot</td>
        </tr>
        <tr>
            <td>metal:use-macro</td>
            <td>data-muse-macro</td>
            <td>Invokes a macro</td>
        </tr>
        <tr>
            <td>tal:attributes</td>
            <td>data-tattributes</td>
            <td>Replace the value of one or more attributes</td>
        </tr>
        <tr>
            <td>tal:condition</td>
            <td>data-tcondition</td>
            <td>Display or hide nodes depending on a condition</td>
        </tr>
        <tr>
            <td>tal:content</td>
            <td>data-tcontent</td>
            <td>Replace the content of the element</td>
        </tr>
        <tr>
            <td>tal:define</td>
            <td>data-tdefine</td>
            <td>Define one or more variables</td>
        </tr>
        <tr>
            <td>tal:on-error</td>
            <td>data-ton-error</td>
            <td>Handle errors</td>
        </tr>
        <tr>
            <td>tal:omit-tag</td>
            <td>data-tomit-tag</td>
            <td>Remove an element, leaving the content of the element</td>
        </tr>
        <tr>
            <td>tal:repeat</td>
            <td>data-trepeat</td>
            <td>Repeat an element</td>
        </tr>
        <tr>
            <td>tal:replace</td>
            <td>data-treplace</td>
            <td>Replace the content of an element and remove the element leaving the content</td>
        </tr>
    </table>
    <p>
        The tags can be changed. Customize the <code>defaultTag</code> variable in <code>js/app/context.js</code> file. You can also use <code>context.setTags( tags )</code> to define the tags programmatically.
        <br> Important: <strong>after this point we will refer to tags as the ZPT-JS tag name</strong>.
    </p>
    
    <a id="tags.originalTags"></a>
    <h3>Using ZPT's original tags</h3>
    <p>
        The <em>data-*</em> attributes is used to store custom data private to the page or application. These are the standard in HTML5. If you prefer to use the original ZPT's attributes use <code>context.useOriginalTags()</code> method:
    </p>
    
    <strong>original-tags-sample.js</strong>
    <pre>
"use strict";

var zpt = require( 'zpt' );

var dictionary = { 
    aString: "string",
    doggy: false,
    number1: 1,
    number100: 100,
    user: {
        name: "Bob", 
        age: function( ){
            return 25;
        }
    },
    items: [ 'item0', 'item1', 'item2' ]
};

// Don't forget to declare to use original tags!
zpt.context.useOriginalTags();

zpt.run({
    root: document.body,
    dictionary: dictionary
});
    </pre>
    
    <strong>original-tags-sample.html</strong>
    <pre>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;Some ZPT-JS examples&lt;/title&gt;

        &lt;script src="original-tags-sample.js" defer&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Some expressions&lt;/h1&gt;
        &lt;ol&gt;
            &lt;li tal:content="user/name"&gt;xxx&lt;/li&gt;
        &lt;/ol&gt;
    &lt;/body&gt;
&lt;/html&gt;
    </pre>
    
    <a id="evaluationOrder"></a>
    <h3>Evaluation order</h3>
    <p>
        The order evaluation of attributes in ZPT-JS is not equal than ZPT's. The new order is:
    </p>
    <ol>
        <li><code>data-trepeat</code></li>
        <li><code>data-ton-error</code></li>
        <li><code>data-mdefine-macro</code></li>
        <li><code>data-tdefine</code></li>
        <li><code>data-tcondition</code></li>
        <li><code>data-tomit-tag</code></li>
        <li><code>data-treplace</code></li>
        <li><code>data-tattributes</code></li>
        <li><code>data-tcontent</code></li>
        <li>content</li>
        <li><code>data-muse-macro</code></li>
    </ol>

    <a id="tales"></a>

    <a id="tales.path"></a>
    <h3>Path Expressions</h3>
    <p>
        The first element in a path expression must be a variable, a method call, a function call or a literal.
    </p>

    <a id="tales.path.literals"></a>
    <h4>Literals</h4>
    <p>
        Integer, float and boolean literals are defined in the same way as in the Javascript language. String literals are delimited by single quotes. Some example literals:
    </p>
    <ul>
        <li><code>9</code> (integer literal)</li>
        <li><code>9.0</code> (floating point literal)</li>
        <li><code>true</code> (boolean literal)</li>
        <li><code>'foobar'</code> (string literal)</li>
    </ul>

    <a id="tales.variables"></a>
    <h4>Variables</h4>
    <p>
        A variable is either predefined, defined via a <code>data-tdefine</code> attribute, or passed in to the template at runtime. The following variables are predefined:
    </p>
    <ul>
        <li><code>repeat</code> see <code><a href="https://docs.zope.org/zope2/zope2book/AppendixC.html#repeat-repeat-an-element">ZPT reference</a></code></li>
    </ul>
    <p>
        The <code>here</code> variable (the context) is not defined in ZPT-JS; it is implicit. The scope of all variables in dictionary is global. Take a look to <a href="#invocation">Invoking ZPT-JS</a> to understand how you can define variables of the dictionary.
        <br /> 
        The scope of the variables defined via a <code>data-tdefine</code> attribute is local. An example:
    </p>
    <pre>
&lt;div data-tdefine="a number"&gt;
    &lt;span data-treplace="a">5&lt;/span&gt;
&lt;/div&gt;
&lt;span data-treplace="a">null&lt;/span&gt;
    </pre>
    <p>
    At the first replace the value in <code>number</code> will be used. At the second replace, a <code>null</code> value (the <code>a</code> variable is out of scope).
    <br /> 
    Global variables are also implemented. Their scope is all document after their definition:
    </p>
    <pre>
&lt;div data-tdefine="global a number"&gt;
    &lt;span data-treplace="a">5&lt;/span&gt;
&lt;/div&gt;
&lt;span data-treplace="a">5&lt;/span&gt;
    </pre>
    <p>
        The following variables are defined in ZPT but not in ZPT-JS:
        <code>here, template, resolver, options, CONTEXTS, root, container, request, user, modules</code>. The following variables are defined in ZPT but aren't yet implemented in ZPT-JS:
        <code>nothing, default, attrs</code>. If you need these, holler.
    </p>

    <a id="tales.path.traversal"></a>
    <h4>Path traversal</h4>
    <p>
        Following the initial path element, path elements are either properties or methods of the preceding object. Examples:
    </p>
    <ul>
        <li><code>object/name</code> will search for a property <code>name</code> in the passed object.</li>
        <li><code>object/name()</code> will search for a method <code>name()</code> in the passed object.</li>
        <li><code>object/name( arg1, arg2 )</code> will search for a method <code>name()</code> in the passed object and pass <code>arg1</code> and <code>arg2</code> as parameters.</li>
        <li><code>object/name()/name2()</code> will search for a method <code>name()</code> in the passed object and then search for a method <code>name2()</code>.</li>
    </ul>
    <p>
        The last element in a path expression may resolve to <code>null</code>, but if an intermediate element resolves to <code>null</code> an <code>Exception</code> will be thrown.
    </p>

    <a id="tales.path.arraysAndObjects"></a>
    <h4>Arrays and objects</h4>
    <p>
        Array members may be accessed using the same syntax as in Javascript. Any number of dimensions are supported. The expression inside the array accessor may be any TALES expression and must evaluate to an integer value.
    </p>
    <ul>
        <li><code>people[ 2 ]</code></li>
        <li><code>people[ index ]</code></li>
    </ul>
    <p>
        Object properties may be accessed using the same syntax as in Javascript too.
    </p>
    <ul>
        <li><code>user[ 'name' ]</code></li>
        <li><code>user[ member ]</code></li>
    </ul>
    

    <a id="tales.javascript"></a>
    <h3>Javascript expressions</h3>
    <p>
        Javascript expressions work just like Python expressions in ZPT except that the Javascript language is used instead of Python. Any legal Javascript expression may be evaluated. Some examples:
    </p>
    <ul>
        <li><code>js: 4 + 5</code> returns the int 9</li>
        <li><code>js: ${aNumber} + 1</code> returns the result of adding 1 to the value of <code>aNumber</code> variable.</li>
    </ul>

    <a id="tales.exists"></a>
    <h3>Exists expressions</h3>
    <p>
        It evaluates as a boolean expression. If the expression is any of the next:
    </p>
    <ul>
        <li><code>undefined</code></li>
        <li><code>null</code></li>
        <li><code>'false'</code></li>
        <li><code>false</code></li>
        <li><code>0</code></li>
    </ul>
    <p>
        the expression evaluates to <code>false</code>. Otherwise the expression evaluates to <code>true</code>. If an exception is thrown trying to evaluate the expression, it evaluates to <code>false</code>.
    </p>

    <a id="tales.not"></a>
    <h3>Not expressions</h3>
    <p>
        Not expressions work more or less like in ZPT. The expression to which <code>not:</code> is applied must first be cast to a boolean. The result is then negated.
    </p>

    <a id="tales.math"></a>
    <h3>Math expressions</h3>
    <p>
        You can do some math operations using this expressions:
    </p>
    <ul>
        <li><code>+: x y</code> -> add x and y</li>
        <li><code>-: x y</code> -> subtract y from x</li>
        <li><code>*: x y</code> -> multiply x and y</li>
        <li><code>/: x y</code> -> divide x by y</li>
        <li><code>%: x y</code> -> x mod y</li>
    </ul>
    <p>
        In all cases, <code>x</code> and <code>y</code> are assumed integers. You can use more than 2 values to operate. You can use parenthesis. Some examples:
    </p>
    <ul>
        <li><code>-: assets liabilities</code></li>
        <li><code>*: 2 children</code></li>
        <li><code>+: 1 number1 number2</code></li>
        <li><code>+: 1 ( *: number1 number2 )</code></li>
    </ul>

    <a id="tales.bool"></a>
    <h3>Boolean expressions</h3>
    <p>
        The list of available boolean expressions are:
    </p>
    <ul>
        <li><code>or: x y</code> -> boolean or of expressions x and y</li>
        <li><code>and: x y</code> -> boolean and of expressions x and y</li>
        <li><code>cond: x y z</code> -> evaluate as boolean x; if true return y, otherwise return z</li>
    </ul>
    <p>
        All operators uses lazy evaluation. OR and AND expressions support 2 or more operators. COND expression only support 3. An example:
    </p>
    <ul>
        <li><code>&lt;p data-tcondition="and: ( exists:pets()/dog() ) ( not:pets()/dog()/badDog() )"&gt;
              Good Dog&lt;/p&gt;</code></li>
        <li><code>&lt;p data-tcondition="or: isFridayNight isSaturday isSunday"&gt;
              Yeah!&lt;/p&gt;</code></li>
        <li><code>&lt;p data-tcontent="cond: isFridayNight 'Yeah!' 'Oh!'"&gt;
              What?&lt;/p&gt;</code></li>
    </ul>

    <a id="tales.comparison"></a>
    <h3>Comparison expressions</h3>
    <p>
        The 4 available comparison expressions are:
    </p>
    <ul>
        <li><code>equals:</code> Checks if 2 or more integers are equals. If the values are not numbers, it checks if they are equals.</li>
        <li><code>in:</code> Checks if a value is in a list of expressions.</li>
        <li><code>greater:</code> Checks if a number is greater than another.</li>
        <li><code>lower:</code> Checks if a number is lower than another.</li>
    </ul>
    <p>
        Some examples:
    </p>
    <ul>
        <li><code>equals: assets liabilities anObject</code> -> <code>True</code> if <code>assets</code>, <code>liabilities</code> and <code>anObject</code> are all equals.</li>
        <li><code>in: value 'option1' 'option2' 'option3'</code> -> <code>True</code> if <code>value</code> is <code>'option1'</code>, <code>'option2'</code> or <code>'option3'</code>.</li>
        <li><code>greater: 10 ( +: children pets )</code> -> <code>True</code> if <code>10 > ( children + pets)</code>.</li>
    </ul>

    <a id="tales.jquery"></a>
    <h3>Jquery expressions</h3>
    <p>
        ZPT-JS supports some jquery expressions:
    </p>

    <pre>
&lt;div&gt;
    &lt;div&gt;value1 = &lt;span id="value1" class="values"&gt;10&lt;/span&gt;&lt;/div&gt;
    &lt;div&gt;value2 = &lt;span id="value2" class="values"&gt;20&lt;/span&gt;&lt;/div&gt;
    &lt;div&gt;value3 = &lt;span id="value3" class="values"&gt;30&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;div data-tcontent="$('#value1')"&gt;must be 10&lt;/div&gt;
    &lt;div data-tcontent="$('.values')"&gt;must be 10,20,30&lt;/div&gt;
    &lt;div data-tcontent="+: $('.values')"&gt;must be 10 + 20 + 30 = 60&lt;/div&gt;
    &lt;div data-tcontent="+: 100 $( '.values' )"&gt;must be 100 + 10 + 20 + 30 = 160&lt;/div&gt;
&lt;/div&gt;
    </pre>

    <a id="tales.other"></a>
    <h3>Other expressions</h3>
    <p>
        String expressions behave exactly as in ZPT. Python expressions are not supported in ZPT-JS.
    </p>
    
    <a id="tales.defaultVars"></a>
    <h3>Default vars</h3>
    <p>
        ZPT-JS register the <em>window</em> object automatically, so global variables defined via javascript can be used easily:
    </p>
    <pre>
&lt;div data-tcontent="window/globalVar"&gt;a string&lt;/div&gt;
    </pre>
    <p>
        ZPT-JS also register the <em>context</em> object automatically, so ZPT's configuration is available too:
    </p>
    <pre>
&lt;div data-tcontent="context/getConf()/externalMacroPrefixURL"&gt;a string&lt;/div&gt;
    </pre>
    
    <a id="tal"></a>
    <h2>TAL Statements</h2>
    <p>
        All TAL statements behave almost exactly as in ZPT, except:
    </p>
    <ul>
        <li><code>tal:no-call</code>: not yet implemented</li>
        <li><code>data-tcondition</code> and <code>data-tomit-tag</code>: must cast their expression to a boolean, which follows the rules described for <a href="#tales.not">Not expressions</a>.</li>
        <li><code>data-treplace</code> and <code>data-tomit-tag</code>: because ZPT-JS modifies directly the template (ZPT generates a new document), these tags are REMOVED when they are not inside a macro definition. So if you update the dictionary a run ZPT-JS a second time these tags does not exist yet. If you need this to work place <code>data-treplace</code> and <code>data-tomit-tag</code> inside a macro definition and invoke it. See <a href="#metal">macros</a>.</li>
    </ul>

    <a id="tal.repeat"></a>
    <h3>Repeat expressions</h3>
    <p>
        There are a few minor variations for <code>tal:repeat</code>. The repeat expression must evaluate to an array.
    </p>

    <a id="tal.range"></a>
    <h3>Lists expressions</h3>
    <p>
        A list is defined as an enumeration of items in brackets. Some examples:
    </p>
    <ul>
        <li><code>[1 2 3]</code> evaluates as 1,2,3</li>
        <li><code>[1 2 3 number1]</code> evaluates as 1,2,3,1 (if the value of <code>number1</code> is 1)</li>
    </ul>
    <p>
        You can iterate through lists using loops:
    </p>
    <ul>
        <li><code>data-trepeat="c [10 20 30]"</code> iterates using <code>c</code> through 10, 20 and 30</li>
        <li><code>data-trepeat="mixed ['yes!' 'no!' aNumber]"</code> iterates using <code>mixed</code></li>
    </ul>
    <p>
        Another ways of using lists is as range expressions:
    </p>
    <ul>
        <li><code>data-trepeat="c [1:5]"</code> iterates using <code>c</code> through 1,2,3,4 and 5</li>
        <li><code>data-trepeat="c [1:7:2]"</code> iterates using <code>c</code> through 1,3,5 and 7</li>
        <li><code>data-trepeat="c [:5]"</code> iterates using <code>c</code> through 0,1,2,3,4 and 5</li>
    </ul>
    
    <p>
        Lists are very versatile:
    </p>
    <ul>
        <li><code>[1:3 10]</code> evaluates to 1,2,3 and 10</li>
        <li><code>[4 1:3 10]</code> evaluates to 4,1,2,3 and 10</li>
    </ul>
    
    <p>
        ...and can be used in arithmethic operations:
    </p>
    <ul>
        <li><code>+: [1:3 10]</code> evaluates to 1+2+3+10 = 16</li>
        <li><code>+: [4 1:3 10]</code> evaluates to 4+1+2+3+10 = 20</li>
    </ul>
    
    Don't forget to not use spaces inside ranges! 
    <ul>
        <li><code>[ 1 : 3 ]</code> will not work!</li>
    </ul>
    
    <a id="tal.attributes"></a>
    <h3>Attributes</h3>
    
    <p>
        ZPT's version of <code>data-tattributes</code> forces to uses key/values pairs. ZPT-JS also allows to use javascript objects. If we define a dictionary this way:
    </p>
    <pre>
var dictionary = { 
    textareaAttrs: {
        rows: 10,
        cols: 100
    }
};
    </pre>
    <p>
        ...we can use this in a template:
    </p>
    <pre>
&lt;textarea data-tattributes="placeholder 'Write something here!';
                            textareaAttrs;
                            maxlength 200"&gt;&lt;/textarea&gt;
    </pre>
    
    <a id="metal"></a>
    <h2>METAL</h2>
    <p>
        METAL statements behave exactly as in ZPT. The main difference, which is really a difference in Path expressions, is the means of finding another template which contains macros. There is no Zope tree in which to locate templates. Use-macro tag uses expressions (ZPT's version does not, it uses literals).
    </p>

    <a id="metal.local"></a>
    <h3>Local macros</h3>
    <p>
        Local macros are defined at the same HTML file where they are invoked. An example of definition of a local macro:
    </p>
    <pre>
&lt;ul data-mdefine-macro="list"&gt;
    &lt;li data-trepeat="item items"&gt;
        &lt;span data-tcontent="item"&gt;An item&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;
    </pre>
    <p>
        That macro generates an unordered list iterating through the <code>items</code> variable. Let's invoke them; to do this, the next HTML code must be at the same file.
    </p>
    <pre>
&lt;div data-tdefine="items [10 20 30]" data-muse-macro="'list'"&gt;
    Macro goes here
&lt;/div&gt;
    </pre>
    <p>
        ZPT-JS allows to uses expressions when using macros. The next HTML code invokes the same macro if the value of <code>listMacro</code> variable is <code>list</code>:
    </p>
    <pre>
&lt;div data-tdefine="items [10 20 30]" data-muse-macro="'listMacro'"&gt;
    Macro goes here
&lt;/div&gt;
    </pre>
    
    <a id="metal.external"></a>
    <h3>External macros</h3>
    <p>
        External macros are defined at a different page that where they are invoked. They only differ how they are invoked; if we want to invoke the macro <code>list</code> defined in <code>macros.html</code> file:
    </p>
    <pre>
&lt;div data-tdefine="items [10 20 30]" data-muse-macro="'list@macros.html'"&gt;
    Macro goes here
&lt;/div&gt;
    </pre>
    <p>
        External macro files must be preloaded before the template is rendered, so code is async:
    </p>  
    <pre>
var zptParser = zpt.buildParser({
    root: document.body,
    dictionary: dictionary
});

zptParser.init(
    function(){
        zptParser.run();
        [ your code here ]
    }
);
    </pre>
    <p>
        Because external macro files must be preloaded before the template is rendered, ZPT-JS must to know the list of external files invoked in the template. If we use literal string expressions or expressions that can be evaluated using only dictionary there is nothing to do. But if we use an expression that can not be resolved at first like this:
    </p>
    <pre>
&lt;div data-muse-macro="anObject/templateName"&gt;
    Macro goes here
&lt;/div&gt;
    </pre>
    <p>
        If <code>anObject/templateName</code> evaluates to <code>aMacro@macros.html</code> and there is no rederence to <code>macros.html</code> in other macro invokations, that macro invokation will throw an exception: <code>Macros in URL 'macros.html' not preloaded!</code>. To resolve this issue we must set manually the list of external macro files we want to use when executing  the ZPT call:
    </p>
    <pre>
var zptParser = zpt.buildParser({
    root: document.body,
    dictionary: dictionary,
    declaredRemotePageUrls: [ 'macros.html', 'moreMacros.html' ]
});

zptParser.init(
    function(){
        zptParser.run();
        [ your code here ]
    }
);
    </pre>
    <p>
        URLs are by default relative to current URL. You can also use absolute URLs:
    </p>
    <pre>
var zptParser = zpt.buildParser({
    root: document.body,
    dictionary: dictionary,
    declaredRemotePageUrls: [ '/path/to/your/macro/macros.html' ]
});
...
    </pre>
    <p>
        And in your HTML code:
    </p>
    <pre>
&lt;div data-muse-macro="'myMacro@/path/to/your/macro/macros.html'"&gt;
    Macro goes here
&lt;/div&gt;
    </pre>
    <p>
        <em>Context</em> object provides a conf property to set a prefix to all relative URLs:
    </p>
    <pre>
context.getConf().externalMacroPrefixURL = '/path/to/your/templates/';
    </pre>
    <p>
        Then if you use an URL like <em>macros.html</em> it will be replaced by <em>/path/to/your/templates/macros.html</em>.
    </p>
    
    <p>
        Optionally you can add a fail callback function to manage initialization errors:
    </p>
    <pre>
zptParser.init(
    function(){
        zptParser.run();
        [ your code here ]
    },
    function( msg ){
        [ your code to manage initialization errors here ]
    }
);
    </pre>
    <p>
        <em>msg</em> is the error message.
    </p>
    
    <a id="formatters"></a>
    <h2>Formatters</h2>
    <p>
        A <code>formatter</code> allows to format the evaluation of an expression. ZPT-JS includes some formatters:
    </p>
    <ul>
        <li><code>format: lowerCase 'Test'</code> evaluates as 'test'</li>
        <li><code>format: upperCase 'TEST'</code> evaluates as 'TEST'</li>
        <li><code>format: fix 1.371 2</code> evaluates as '1.37'</li>
        <li><code>format: fix (/: 1 3) 2</code> evaluates as '0.33'</li>
    </ul>
        
    <p>
        You can register other formatters of your own:
    </p>
    <pre>
context.registerFormatter( 
    'myCustomFormatter', 
    function( value ){
        return "$" + value;
    }
);
    </pre>
    <p>
        After registering it you will be able to use it as usual:
    </p>
    <ul>
        <li><code>format: myCustomFormatter aNumber</code></li>
    </ul>
    
    <p>
        It is possible to run custom formatters without registering them. They must be functions defined in the dictionary:
    </p>
    <ul>
        <li><code>format: customFormatter aNumber</code> formats aNumber using a function in the dictionary called <code>customFormatter</code></li>
        <li><code>format: customFormatterName aNumber</code> formats aNumber using a function in the dictionary called as the value of the <code>customFormatterName</code> variable</li>
    </ul>
    
    <a id="i18n"></a>
    <h3>I18n and l10n</h3>
    
    <h4>Basics about i18n</h4>
    <p>
        Nowadays ZPT-JS has some i18n capabilities. How do they work? Let's see an example:
    </p>
    
    <strong>i18n.js</strong>
    <pre>
"use strict";

var zpt = require( '../../../js/app/main.js' );
var I18n = require( '../../../js/app/i18n/i18n.js' );
var I18nBundle = require( '../../../js/app/i18n/i18nBundle.js' );

/* I18n maps init */
var msg = {
    en : {},
    es : {}
};

/* English i18n messages */
msg.en[ '/CONF/' ] = {
    language: 'en',
    locale: 'en-US'
};
msg.en[ 'Hello world!' ] = 'Hello world!';
msg.en[ 'Results msg' ] = '{GENDER, select, male{He} female{She} other{They} }' +
    ' found ' +
    '{RES, plural, =0{no results} one{1 result} other{# results} }';

/* Spanish i18n messages */
msg.es[ '/CONF/' ] = {
    language: 'es',
    locale: 'es-ES'
};
msg.es[ 'Hello world!' ] = '¡Hola mundo!';
msg.es[ 'Results msg' ] = '{ GENDER, select, male{Él} female{Ella} other{Ellos} }' +
    ' ' +
    '{ RES, plural, =0{no } other{} }' +
    '{ GENDER, select, male{ha} female{ha} other{han} }' +
    ' encontrado ' +
    '{ RES, plural, =0{ningún resultado} one{un único resultado} other{# resultados} }';

// Create I18n and i18nBundle instances
var i18nES = new I18n( 'es', msg[ 'es' ] );
var i18nEN = new I18n( 'en', msg[ 'en' ] );
var i18nBundle = new I18nBundle( i18nES, i18nEN );

// Init dictionary
var dictionary = {
    'i18nBundle': i18nBundle
};

// Parse template
zpt.run({
    root: document.body,
    dictionary: dictionary
});
    </pre>
    
    <strong>i18n.html</strong>
    <pre>
&lt;!DOCTYPE html&gt;
&lt;html lang="es"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;Some I18n examples&lt;/title&gt;
        
        &lt;script src="i18n.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Some I18n expressions&lt;/h1&gt;
        &lt;ol data-ilanguage="'en'" data-idomain="i18nBundle"&gt;
            &lt;li&gt;
               ¡Hola mundo! = 
               &lt;span data-tcontent="tr: 'Hello world!'"&gt;Must be ¡Hola mundo!&lt;/span&gt;
            &lt;/li&gt;
            &lt;li&gt;
               Él ha encontrado 10 resultados = 
                &lt;span data-tcontent="tr: 'Results msg' ( GENDER 'male'; RES 10 )"&gt;Must be 'Él ha encontrado 10 resultados'&lt;/span&gt;
            &lt;/li&gt;
        &lt;/ol&gt;
    &lt;/body&gt;
&lt;/html&gt;
    </pre>
    
    <p>
        Some remarks about this:
    </p>
    <ul>
        <li>The dictionary must contain a source of i18n resources. ZPT-JS supports these types:
            <ul>
                <li>An instance of <code>I18n</code> class. Each instance includes all i18n strings in an i18n file in JSON format. The constructor of <code>I18n</code> class accepts 2 arguments; the first is the language of the messages and the second is a map (keys are the id of the messages and values the message themselves). The format of the messages must complain <a href="http://userguide.icu-project.org/formatparse/messages">ICU standards</a>.</li>
                <li>An array of instances of <code>I18n</code> classes.</li>
                <li>An instance of <code>I18nBundle</code> class. An instance of this class groups an instance of <code>I18n</code> class per supported language. They are useful to support using several languages in a template.</li>
            </ul>    
        </li>
        <li>The <code>data-idomain</code> attribute defines the source of i18n resources to use. It can be one or several instances of <code>I18n</code> or <code>I18nBundle</code> classes or an array of them.</li>
        <li>The <code>data-ilanguage</code> attribute defines the current language to use. It is needed when <code>data-idomain</code> contains a <code>I18nBundle</code> instance, it is useless when we use <code>I18n</code> instances.</li>
        <li>The <code>tr</code> expression  evaluates an expression but then it searches that value into the messages.</li>
        <li>The expression <code>'Hello world!'</code> is a literal, but <code>'Results msg' ( GENDER 'male'; RES 10 )</code> is a little more complex:
            <ol>
                <li>The first item is the message id: <code>'Results msg'</code>.</li>
                <li>The rest are variables used to build the message: <code>GENDER 'male'</code> defines a <code>GENDER</code> variable with <code>'male'</code> as value.</li>
                <li><code>RES 10</code> defines a <code>RES</code> variable with <code>10</code> as value.</li>
            </ol>
        </li>
    </ul>
    
    <h4>Some examples</h4>
    <p>
        Some examples of i18n tags in action:
    </p>
    <ul>
        <li>
            <code>&lt;img src="image.png" data-tattributes="title tr: 'Hello world!'"&gt;</code> adds an i18n title to the image.
        </li>
        <li>
            <code>&lt;li data-tdefine="msg tr: 'Hello world!'"&gt;</code> defines a <code>msg</code> variable with the i18n message of <code>'Hello world!'</code>.
        </li>
        <li>
            <code>&lt;body data-ton-error="tr: 'Oh, noooo!'"&gt;</code> sets the i18n message of <code>'Oh, noooo!'</code> as the message to show if an error occurs.
        </li>
        <li><code>&lt;span data-treplace="tr: 'Hello world!'"&gt;</code> replaces the <code>span</code> tag by the i18n message of <code>'Hello world!'</code>.</li>
    </ul>
    <p>
        Some examples of valid <code>data-idomain</code> attributes:
    </p>
    <ul>
        <li><code>data-idomain="i18nES1"</code> Defines an instance of <code>I18n</code> class as the source of i18n strings.</li>
        <li><code>data-idomain="i18nES2 i18nES1"</code> Defines 2 instances of <code>I18n</code> class as the source of i18n strings. ZPT will use the <em>i18nES2</em> instance first; if the string is not found will be use <em>i18nES1</em> instance.</li>
        <li><code>data-idomain="i18nBundle1"</code> Defines an instance of <code>I18nBundle</code> class as the source of i18n strings.</li>
        <li><code>data-idomain="i18nBundle2 i18nBundle1"</code>Defines 2 instances of <code>I18nBundle</code> class as the source of i18n strings.</li>
        <li><code>data-idomain="i18nESArray"</code> Defines an array of instances of <code>I18n</code> class as the source of i18n strings. ZPT will use the first instance in the array; if the string is not found will be use the next instance until it is found.</li>
    </ul>
    
    <h4>Working with domains</h4>
    <p>
        In the previous example the domain was a simple <code>I18nBundle</code> instance. This forces to use big maps with all the messages of one language. This can be awful if the amount of messages is big. <code>data-idomain</code> tag supports also a list of <code>I18nBundle</code> instances, so the messages will be searched in the same order.
    </p>
    <p>
        Therefore, <code>data-idomain="i18nBundle1 i18nBundle2"</code> allows to organise your i18n messages in 2 maps. The first one can contain general messages and the second one more particular messages (for example).
    </p>
    
    <p>
        <code>data-idomain</code> also supports nested definitions:
    </p>
    <pre>
&lt;div data-idomain="i18nBundle1"&gt;
   &lt;span data-tcontent="tr: 'Hello world!'"&gt;
        ¡Hola mundo!
   &lt;/span&gt;
   &lt;span data-idomain="i18nBundle2" data-tcontent="tr: 'Hello world!'"&gt;
        ¡¡¡Hola mundo 2!!!
   &lt;/span&gt;
&lt;/div&gt; 
    </pre>
    <p>
        The first <code>data-tcontent</code> will search only in <code>i18nBundle1</code>. The second one will search first in <code>i18nBundle2</code> and if it is not found will search in <code>i18nBundle1</code>.
    </p>
    
    <h4>Loading messages from JSON files</h4>
    <p>
        ZPT-JS makes it easy loading i18n messages from JSON files:
    </p>
    <pre>
"use strict";

var zpt = require( '../../../js/app/main.js' );

var dictionary = {
    ...
};

var zptParser = zpt.buildParser({
    root: document.body,
    dictionary: dictionary,
    i18n: {
        urlPrefix: './i18n/',
        files: {
            'es': [ 'es1.json', 'es2.json' ],
            'en': [ 'en1.json', 'en2.json' ]
        }
    }
});

zptParser.init(
    function(){
    
        // Add I18nBundle instances to dictionary
        var dictionaryExtension = {
            i18nBundle1: new I18nBundle( dictionary.i18nES1, dictionary.i18nEN1 ),
            i18nBundle2: new I18nBundle( dictionary.i18nES2, dictionary.i18nEN2 )
        };
        $.extend( true, dictionary, dictionaryExtension );
            
        zptParser.run();
    }
);
    </pre>
    <p>
        ZPT will add to dictionary these vars:
    </p>
    <ul>
        <li><em>i18nES1</em>. Includes all texts from <em>es1.json</em> file.</li>
        <li><em>i18nES2</em>. Includes all texts from <em>es2.json</em> file.</li>
        <li><em>i18nEN1</em>. Includes all texts from <em>en1.json</em> file.</li>
        <li><em>i18nEN2</em>. Includes all texts from <em>en2.json</em> file.</li>
        <li><em>i18nESArray</em>. An array with all spanish texts, in this example <em>[ i18nES2, i18nES1 ]</em>.</li>
        <li><em>i18nENArray</em>. An array with all english texts, in this example <em>[ i18nEN2, i18nEN1 ]</em>.</li>
        <li><em>i18nArray</em>. An array with all texts defined only if only one language is present. In this example it would not be defined, there are 2 languages.</li>
    </ul>
    <p>
        The order in arrays is inverted: first the last files, then the first. 
    </p>
    <p>
        The bundles (<em>i18nBundle1</em> and <em>i18nBundle2</em>) are not required, add to the dictionary if you need them.
    </p>
    
    <h4>Numbers</h4>
    <p>
        ZPT-JS uses <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Intl">Intl</a> as i18n API for numbers. Let's see some examples:
    </p>
    <ul>
        <li>
            <code>&lt;span data-tcontent="trNumber: 1355.23"&gt;</code> formats that number depending on the active i18n domain (<em>1,355.23</em> in english, <em>1.355,23</em> in spanish...).
        </li>
        <li>
            <code>&lt;span data-tcontent="trNumber: 1355.23643 ( maximumFractionDigits 3 )"&gt;</code> formats that number depending on the active i18n domain and using a maximum of 3 fraction digits (<em>1,355.236</em> in english, <em>1.355,236</em> in spanish...).
        </li>
        <li>
            <code>&lt;span data-tcontent="trNumber: 1355.23643 ( maximumFractionDigits 3; minimumIntegerDigits 6 )"&gt;</code> formats that number depending on the active i18n domain and using a maximum of 3 fraction digits and a minimum of 6 integer digits (<em>001,355.236</em> in english, <em>001.355,236</em> in spanish...).
        </li>
    </ul>
    
    <p>
        Take a look on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat">NumberFormat options</a> to see all available options.
    </p>
    
    <h4>Currencies</h4>
    <p>
        ZPT-JS uses <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Intl">Intl</a> as i18n API for currencies. Let's see some examples:
    </p>
    <ul>
        <li>
            <code>&lt;span data-tcontent="trCurrency: 'EUR' 1355.23"&gt;</code> formats that number depending on the active i18n domain and using that currency (<em>€ 1,355.23</em> in english, <em>1.355,23 €</em> in spanish...).
        </li>
        <li>
            <code>&lt;span data-tcontent="trCurrency: 'USD' 1355.23 ( currencyDisplay 'name' )"&gt;</code> uses the name of the currency (<em>1,355.23 US dollars</em> in english, <em>1.355,23 € dólares estadounidenses</em> in spanish...).
        </li>
    </ul>
    
    <p>
        Options are the same as numbers (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat">NumberFormat options</a>) plus some specific options of currencies.
    </p>
    
    <h4>Dates and times</h4>
    <p>
        ZPT-JS uses <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Intl">Intl</a> as i18n API for date and times. Let's see some examples:
    </p>
    <ul>
        <li>
            <code>&lt;span data-tcontent="trDate: ( js: new Date( Date.UTC( 2012, 11, 21, 3, 0, 0 ) ) )"&gt;</code> formats that date depending on the active i18n domain (<em>12/21/2012</em> in english, <em>21/12/2012</em> in spanish...).
        </li>
        <li>
            <code>&lt;span data-tcontent="trDate: ( js: new Date( Date.UTC( 2012, 11, 21, 3, 0, 0 ) ) ) (  weekday 'long'; year 'numeric'; month 'long'; day 'numeric' )"&gt;</code> formats that date with some options (<em>Friday, December 21, 2012</em> in english, <em>viernes, 21 de diciembre de 2012</em> in spanish...).
        </li>
        <li>
            <code>&lt;span data-tcontent="trDate: ( js: new Date( Date.UTC( 2012, 11, 21, 3, 0, 0 ) ) ) ( hour 'numeric'; minute 'numeric';  second 'numeric' )"&gt;</code> formats that date with some options (<em>4:00:00 AM</em> in english, <em>4:00:00</em> in spanish...).
        </li>
    </ul>
    
    <p>
        Take a look on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat">DateTimeFormat options</a> to see all available options.
    </p>
    
    <a id="customExpressions"></a>
    <h3>Custom expressions</h3>
    <p>
        ZPT-JS makes it easy to register custom expression managers. For example, we want to develop an expression manager that operates similarly to the <code>++</code> C operator. First we must implement the class (incExpression.js file):
    </p>
    <pre>
"use strict";

var context = require( '../../../js/app/context.js' );
var evaluateHelper = require( '../../../js/app/expressions/evaluateHelper.js' );
var $ = require( 'jquery' );

var IncExpression = function( varNameToApply ) {
    
    var varName = varNameToApply;
    
    var evaluate = function( scope ){
        
        var value = scope.get( varName );
        
        if ( ! evaluateHelper.isNumber( value ) ) {
            throw 'Error trying to inc number, not a number!';
        }
        
        scope.set( varName, ++value, true );
        
        return value;
    };
    
    return {
        evaluate: evaluate
    };
};

IncExpression.removePrefix = true;
IncExpression.getPrefix = function() {
    return '++' + context.getConf().expressionSuffix;
};
IncExpression.getId = IncExpression.getPrefix;

IncExpression.build = function( string ) {
    return new IncExpression( string.trim() );
}

module.exports = IncExpression;
    </pre>
    
    <p>
        Don't forget to register that class!
    </p>
    <pre>
var expressionBuilder = require( '../../../js/app/expressions/expressionBuilder.js' );
var IncExpression = require( './incExpression.js' );

expressionBuilder.register( require( IncExpression ) );
    </pre>
    
    <a id="grunt"></a>
    <h3>Building and testing</h3>
    <p>
        At first use the next command to initialize a <a href="http://didact.us/beefy/">beefy server</a> (port 9966) to make it easy to test ZPT-JS without browserifying by hand and a <a href="https://www.npmjs.com/package/http-server">HTTP server</a> (port 9000) to serve static files (HTML, CSS and JSON files).
    </p>
    <pre>
$ npm run start
    </pre>   
    <p>
        ZPT-JS uses <a href="https://qunitjs.com/">QUnit</a> as testing framework. For testing ZPT-JS open <code>test/index.html</code> or <a href="http://localhost:9000/test/">http://localhost:9000/test/</a> with your favourite browser. All tests passed using last versions of Mozilla Firefox (55.0.2, 64-bit). Perhaps some tests fail using other browsers!
    </p>
    <p>
        ZPT-JS uses <a href="http://gruntjs.com/">Grunt</a> as task runner tool. If you want to modify and rebuild ZPT-JS the next command lines are useful:
    </p>
    <pre>
$ grunt browserify        // Build all test js files; also build a standalone version
$ grunt browserify:[file] // Build a single js file; use 'standalone' to build a standalone version
$ grunt compress          // Compress files and folders of this project into dist/zpt_yyyy-mm-dd_hhmm.tar.gz
    </pre>
    
    <a id="moreExamples"></a>
    <h2>More examples</h2>
    <p>
        Please, take a look to test files in <code>test/</code> to view more ZPT-JS examples.
    </p>
</body>

</html>