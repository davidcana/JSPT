<html>
  <head>
    <title>ZPT-JS: User's Guide</title>
    <style>
      body { 
        background-color: white; 
        font-size: 12pt; 
        color: black; 
        font-family: arial,helvetica,verdana; 
      }
      h1 { font-size: 24pt; font-weight: bold; }
      h2 { font-size: 20pt; font-weight: bold; }
      h3 { font-size: 18pt; font-weight: bold; }
      h4 { font-size: 16pt; font-weight: bold; }
      table, th, td { border: 1px solid black; }
      .sub { font-size: 10pt; }
      code { color: red; }
      pre { background-color: black; color: white; padding-top: 1em; padding-left: 4em;}
    </style>
  </head>
  <body>
    <a name="top"></a>
    <h1>ZPT-JS: User's Guide</h1>
    <div class="sub">last modified: 2015/22/04</div>
    <div class="sub">author <a href="mailto:chris@christophermrossi.com">Chris Rossi</a></div>
    <div class="sub">contributed by <a href="mailto:david.javapagetemplates@gmail.com">David Cana</a></div>

    <a name="zpt"></a>
    <h2>Zope Page Templates</h2>
    <p>
      ZPT-JS is a Javascript implementation of Zope Page Templates (ZPT). Because ZPT-JS
      isn't running in the context of Zope and isn't written with Python,
      there are necessarily some differences between ZPT-JS and ZPT. This document
      will concentrate on the ways that ZPT-JS differs from ZPT. For an introduction
      to ZPT refer to the chapter 
      <a href="http://docs.zope.org/zope2/zope2book/ZPT.html">Using
      Zope Page Templates</a> in the 
      <a href="http://docs.zope.org/zope2/zope2book/">Zope Book</a>.
      For a complete reference to ZPT, refer to the 
      <a href="http://docs.zope.org/zope2/zope2book/AppendixC.html">ZPT Reference</a>.
    </p>
    
    <a name="zpt.grunt"></a>
    <h3>Building and testing</h3>
    <p>
      ZPT-JS uses <a href="http://gruntjs.com/">Grunt</a> as task runner tool. If you know
      how a Grunt project works you can skip this chapter.
    </p>
    <p>
      If you want to modify and rebuild ZPT-JS the next command lines are useful:
      <pre>
grunt concat    // Concatenate all scripts in the scripts sub-directory into a single script called dist/jspt.js
grunt uglify    // Create a file within dist/jspt.min.js that contains the result of minifying the JavaScript files
grunt compress  // Compress files and folders of this project into dist/jspt_yyyy-mm-dd_hhmm.tar.gz
      </pre>
    </p>
    <p>
      ZPT-JS uses <a href="https://qunitjs.com/">QUnit</a> as testing framework. For testing ZPT-JS open test/index.html with your
      favourite browser.
    </p>
    
    <a name="zpt.tags"></a>
    <h3>ZPT-JS tags</h3>
    <p>
      The name of tags are not the same because if they were the resulting HTML douments will not be well formed. The list of 
      tags with their equivalences are:
      <table>
        <tr>
            <th>ZPT tag name</th>
            <th>ZPT-JS tag name</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>metal:define-macro</td>
            <td>data-mdefine-macro</td>
            <td>Defines a macro</td>
        </tr>
        <tr>
            <td>metal:define-slot</td>
            <td>data-mdefine-slot</td>
            <td>Defines a slot to make possible to fill it later</td>
        </tr>
        <tr>
            <td>metal:fill-slot</td>
            <td>data-mfill-slot</td>
            <td>Fills a slot</td>
        </tr>
        <tr>
            <td>metal:use-macro</td>
            <td>data-muse-macro</td>
            <td>Invokes a macro</td>
        </tr>
        <tr>
            <td>tal:attributes</td>
            <td>data-tattributes</td>
            <td>Replace the value of one or more attributes</td>
        </tr>
        <tr>
            <td>tal:condition</td>
            <td>data-tcondition</td>
            <td>Display or hide nodes depending on a condition</td>
        </tr>
        <tr>
            <td>tal:content</td>
            <td>data-tcontent</td>
            <td>Replace the content of the element</td>
        </tr>
        <tr>
            <td>tal:define</td>
            <td>data-tdefine</td>
            <td>Define one or more variables</td>
        </tr>
        <tr>
            <td>tal:on-error</td>
            <td>data-ton-error</td>
            <td>Handle errors</td>
        </tr>
        <tr>
            <td>tal:omit-tag</td>
            <td>data-tomit-tag</td>
            <td>Remove an element, leaving the content of the element</td>
        </tr>
        <tr>
            <td>tal:repeat</td>
            <td>data-trepeat</td>
            <td>Repeat an element</td>
        </tr>
        <tr>
            <td>tal:replace</td>
            <td>data-treplace</td>
            <td>Replace the content of an element and remove the element leaving the content</td>
        </tr>
      </table>
      The tags can be changed. Customize the <code>defaultTag</code> variable in <code>js/app/jsptContext.js</code> file.
      You can also use <code>jsptContext.setTags( tags )</code> to define the tags programmatically.<br>
      Important: <strong>after this point we will refer to tags as the ZPT-JS tag name</strong>.
    </p>
    
    <a name="zpt.evaluationOrder"></a>
    <h3>Evaluation order</h3>
    <p>
      The order evaluation of attributes in ZPT-JS is not equal than ZPT's. The new order is:
      <ol>
        <li><code>data-trepeat</code></li>
        <li><code>data-ton-error</code></li>
        <li><code>data-mdefine-macro</code></li>
        <li><code>data-tdefine</code></li>
        <li><code>data-tcondition</code></li> 
        <li><code>data-tomit-tag</code></li>
        <li><code>data-treplace</code></li>
        <li><code>data-tattributes</code></li>
        <li><code>data-tcontent</code></li>
        <li>content</li>
        <li><code>data-muse-macro</code></li>
      </ol>
    </p>

    <a name="tales"></a>

    <a name="tales.path"></a>
    <h3>Path Expressions</h3>
    <p>
      The first element in a path expression must be a variable, a method call, a function call or a literal.
    </p>

    <a name="tales.path.literals"></a>
    <h4>Literals</h4>
    <p>
      Integer, float and boolean literals are defined in the same way as in the Javascript language.  
      String literals are delimited by single quotes.  Some example literals:
      <ul>
        <li><code>9</code> (integer literal)</li>
        <li><code>9.0</code> (floating point literal)</li>
        <li><code>true</code> (boolean literal)</li>
        <li><code>'foobar'</code> (string literal)</li>
      </ul>
    </p>

    <a name="tales.variables"></a>
    <h4>Variables</h4>
    <p>
      A variable is either predefined, defined
      via a <code>data-tdefine</code> attribute, or passed in to the template at runtime.  
      The following variables are predefined:
      <ul>
        <li><code>repeat</code> see <code><a href="https://docs.zope.org/zope2/zope2book/AppendixC.html#repeat-repeat-an-element">ZPT reference</a></code></li>
      </ul>
      The <code>here</code> variable (the context) is not defined in ZPT-JS; it is implicit. The scope of all variables in dictionary 
      is global. Take a look to <a href="#invocation">Invoking ZPT-JS</a> to understand how you can define variables of the dictionary.<br />
      The scope of the variables defined via a <code>data-tdefine</code> attribute is local. An example:
      <pre>
&lt;div data-tdefine="a number"&gt;
    &lt;span data-treplace="a">5&lt;/span&gt;
&lt;/div&gt;
&lt;span data-treplace="a">null&lt;/span&gt;
      </pre>
      At the first replace the value in <code>number</code> will be used. At the second replace, a <code>null</code> value (the <code>a</code> variable is out of scope).<br />
      
      Global variables are also implemented. Their scope is all document after their definition: <br />
      <pre>
&lt;div data-tdefine="global a number"&gt;
    &lt;span data-treplace="a">5&lt;/span&gt;
&lt;/div&gt;
&lt;span data-treplace="a">5&lt;/span&gt;
      </pre>
      
      The following variables are defined in ZPT but not in ZPT-JS:
      <code>here, template, resolver, options, CONTEXTS, root, container, request, user, modules</code>.  
      The following variables are defined in ZPT but aren't yet implemented in ZPT-JS:
      <code>nothing, default, attrs</code>.  If you need these, holler.
    </p>

    <a name="tales.path.traversal"></a>
    <h4>Path traversal</h4>
    <p>
      Following the initial path element, path elements are either properties or methods
      of the preceding object. Examples: <br />
      <ul>
        <li><code>object.name</code> will search for a property <code>name</code>
            in the passed object.</li>
        <li><code>object/name()</code> will search for a method <code>name()</code>
            in the passed object.</li>
        <li><code>object/name( arg1, arg2 )</code> will search for a method <code>name()</code>
            in the passed object and pass <code>arg1</code> and <code>arg2</code> as parameters.</li>
        <li><code>object/name()/name2()</code> will search for a method <code>name()</code>
            in the passed object and then search for a method <code>name2()</code>.</li>
      </ul>
      The last element in a path expression may resolve to <code>null</code>, but if an intermediate element resolves
      to <code>null</code> an <code>Exception</code> will be thrown. 
    </p>
    
    <a name="tales.path.arrays"></a>
    <h4>Arrays</h4>
    <p>
      Array members may be accessed using the same syntax as in Javascript. Any number of 
      dimensions are supported. The expression inside the array accessor may be any
      TALES expression and must evaluate to an integer value. If an array accessor
      is found modifying an object that is not an array an exception is thrown.
      <ul>
        <li><code>people[ 2 ]</code></li>
        <li><code>grid[ point / x ][ point / y ]</code></li>
      </ul>
    </p>
    
    <a name="tales.javascript"></a>
    <h3>Javascript expressions</h3>
    <p>
      Javascript expressions work just like Python expressions in ZPT except that the Javascript language
      is used instead of Python. Any legal Javascript expression may be evaluated.
      Some examples:
      <ul>
        <li><code>js: 4 + 5</code> returns the int 9</li>
        <li><code>js: ${aNumber} + 1</code> returns the result of adding 1 to the value of <code>aNumber</code> variable.</li>
      </ul>
    </p>
    
    <a name="tales.exists"></a>
    <h3>Exists expressions</h3>
    <p>
      It evaluates as a boolean expression. If the expression is any of the next:
      <ul>
        <li><code>undefined</code></li>
        <li><code>null</code></li>
        <li><code>'false'</code></li>
        <li><code>false</code></li>
        <li><code>0</code></li>
      </ul>
       the expression evaluates to <code>false</code>. Otherwise the expression evaluates to <code>true</code>.
    </p>

    <a name="tales.not"></a>
    <h3>Not expressions</h3>
    <p>
      Not expressions work more or less like in ZPT. The expression to which <code>not:</code>
      is applied must first be cast to a boolean. The result is then negated.
    </p>
    
    <a name="tales.math">
    <h3>Math expressions</h3>
    <p>
      You can do some math operations using this expressions:
      <ul>
        <li><code>+: x y</code> -> add x and y</li>
        <li><code>-: x y</code> -> subtract y from x</li>
        <li><code>*: x y</code> -> multiply x and y</li>
        <li><code>:: x y</code> -> divide x by y</li>
        <li><code>%: x y</code> -> x mod y</li>
      </ul>
      In all cases, <code>x</code> and <code>y</code> are assumed integers. You can use more than 2 values to operate. 
      You can use parenthesis. Some examples:
      <ul>
        <li><code>-: assets liabilities</code></li>
        <li><code>*: 2 children</code></li>
        <li><code>+: 1 number1 number2</code></li>
        <li><code>+: 1 ( *: number1 number2 )</code></li>
      </ul>
    </p>
    
    <a name="tales.bool">
    <h3>Boolean expressions</h3>
    <p>
      The list of available boolean expressions are:
      <ul>
        <li><code>or: x y</code> -> boolean or of expressions x and y</li>
        <li><code>and: x y</code> -> boolean and of expressions x and y</li>
        <li><code>cond: x y z</code> -> evaluate as boolean x; if true return y, otherwise return z</li>
      </ul>
      All operators uses lazy evaluation. OR and AND expressions support 2 or more operators. COND expression only support 3. An example:
      <ul>
        <li><code>&lt;p data-tcondition="and: ( exists:here/pets/dog ) ( not:here/pets/dog/badDog )"&gt;
                  Good Dog&lt;/p&gt;</code></li>
        <li><code>&lt;p data-tcondition="or: isFridayNight isSaturday isSunday"&gt;
                  Yeah!&lt;/p&gt;</code></li>
        <li><code>&lt;p data-tcontent="cond: isFridayNight 'Yeah!' 'Oh!'"&gt;
                  What?&lt;/p&gt;</code></li>
      </ul>
    <p>
    
    <a name="tales.comparison">
    <h3>Comparison expressions</h3>
    <p>
      The 3 available comparison expressions are:
      <ul>
        <li><code>equals:</code> Checks if 2 or more integers are equals. If the values are not numbers, it checks if they are equals.</li>
        <li><code>greater:</code> Checks if a number is greater than another.</li>
        <li><code>lower:</code> Checks if a number is lower than another.</li>
      </ul>
      Some examples:
      <ul>
        <li><code>equals: assets liabilities anObject</code></li>
        <li><code>greater: 10 ( +: children pets )</code></li>
      </ul>
    </p>
    
    <a name="tales.jquery"></a>
    <h3>Jquery expressions</h3>
    <p>
        ZPT-JS supports some jquery expressions:
        
        <pre>
&lt;div&gt;
    &lt;div&gt;value1 = &lt;span id="value1" class="values"&gt;10&lt;/span&gt;&lt;/div&gt;
    &lt;div&gt;value2 = &lt;span id="value2" class="values"&gt;20&lt;/span&gt;&lt;/div&gt;
    &lt;div&gt;value3 = &lt;span id="value3" class="values"&gt;30&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;div data-tcontent="$('#value1')"&gt;must be 10&lt;/div&gt;
    &lt;div data-tcontent="$('.values')"&gt;must be 10,20,30&lt;/div&gt;
    &lt;div data-tcontent="+: $('.values')"&gt;must be 10 + 20 + 30 = 60&lt;/div&gt;
    &lt;div data-tcontent="+: 100 $( '.values' )"&gt;must be 100 + 10 + 20 + 30 = 160&lt;/div&gt;
&lt;/div&gt;
        </pre>
    </p>
    
    <a name="tales.other"></a>
    <h3>Other expressions</h3>
    <p>
      String expressions behave exactly as in ZPT. Python expressions are not
      supported in ZPT-JS.
    </p>

    <a name="tal"></a>
    <h2>TAL Statements</h2>
    <p>
      All TAL statements behave almost exactly as in ZPT, except for <code>tal:no-call</code> which
      is not yet implemented (if you need it, holler). <code>data-tcondition (tal:condition in ZPT)</code> and 
      <code>data-tomit-tag (tal:omit-tag in ZPT)</code> must cast their expression to a boolean, which follows the rules
      described for <a href="#tales.not">Not expressions</a>.
    </p>

    <a name="tal.repeat"></a>
    <h3>Repeat expressions</h3>
    <p>
      There are a few minor variations for <code>tal:repeat</code>. The repeat expression must 
      evaluate to an array. The repeat variables <code>Letter</code> and <code>Roman</code> have been changed in ZPT-JS to
      <code>capitalLetter</code> and <code>capitalRoman</code>.  
    </p>
    
    <a name="tal.range"></a>
    <h3>Lists expressions</h3>
      <p>
        A list is defined as an enumeration of items in brackets. Some examples:
      <ul>
        <li><code>[1 2 3]</code> evaluates as 1,2,3</li>
        <li><code>[1 2 3 number1]</code> evaluates as 1,2,3,1 (if the value of <code>number1</code> is 1)</li>
      </ul>
      You can iterate through lists using loops:
      <ul>
        <li><code>data-trepeat="c [10 20 30]"</code> iterates using <code>c</code> through 10, 20 and 30</li>
        <li><code>data-trepeat="mixed ['yes!' 'no!' aNumber]"</code> iterates using <code>mixed</code></li>
      </ul>
      Another ways of using lists is as range expressions:
      <ul>
        <li><code>data-trepeat="c [1:5]"</code> iterates using <code>c</code> through 1,2,3,4 and 5</li>
        <li><code>data-trepeat="c [1:7:2]"</code> iterates using <code>c</code> through 1,3,5 and 7</li>
        <li><code>data-trepeat="c [:5]"</code> iterates using <code>c</code> through 0,1,2,3,4 and 5</li>
      </ul>
    </p>
    
    <a name="metal"></a>
    <h2>METAL</h2>
    <p>
      METAL statements behave exactly as in ZPT. The only difference, which is really a difference
      in Path expressions, is the means of finding another template which contains macros. There is 
      no Zope tree in which to locate templates.
     </p>

    <a name="metal.local"></a>
    <h3>Local macros</h3>
    <p>
      Local macros are defined at the same HTML file where they are invoked. An example of definition of a local macro:
      <pre>
&lt;ul data-mdefine-macro="list"&gt;
    &lt;li data-trepeat="item items"&gt;
        &lt;span data-tcontent="item"&gt;An item&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;
      </pre>
      That macro generates an unordered list iterating through the <code>items</code> variable. Let's invoke them;
      to do this, the next HTML code must be at the same file.
      <pre>
&lt;div data-tdefine="items [10 20 30]" data-muse-macro="list"&gt;
    Macro goes here
&lt;/div&gt;
      </pre>
    </p>
    
    <a name="metal.external"></a>
    <h3>External macros</h3>
    <p>
      External macros are defined at a different page that where they are invoked. It only differs how they are invoked;
      if we want to invoke the macro <code>list</code> defined in <code>macros.html</code> file:
      <pre>
&lt;div data-tdefine="items [10 20 30]" data-muse-macro="list/macros.html"&gt;
    Macro goes here
&lt;/div&gt;
      </pre>

    </p>

    <a name="moreExamples">
    <h2>More examples</h2>
    <p>
      Please, take a look to test files in <code>test/</code> to view more ZPT-JS examples.
      
     <a name="invocation"></a>
     <h2>Invoking Javascript Page Templates</h2>
     <p>
       But, how can we use ZPT-JS? The <code>dictionary</code> is used to define global variables.
     </p>
     <p>
       An example of invoking  ZPT-JS:
     <pre>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;Some ZPT-JS examples&lt;/title&gt;
        
        &lt;script src="https://code.jquery.com/jquery-2.0.3.js"&gt;&lt;/script&gt;
        &lt;script src="../dist/jspt.js"&gt;&lt;/script&gt;
        &lt;script&gt;
        
$(function () {
    "use strict";

    var dictionary = { 
        aString: "string",
        doggy: false,
        number1: 1,
        number100: 100,
        user: {
            name: "Bob", 
            age: function( ){
                return 25;
            }
        },
        items: [ 'item0', 'item1', 'item2' ]
    };

    jspt.run( document.body, dictionary );
});

        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Some expressions&lt;/h1&gt;
        &lt;ol&gt;
            &lt;li data-tcontent="user.name"&gt;xxx&lt;/li&gt;
            &lt;li data-tcontent="string:help my ${user.name}"&gt;xxx&lt;/li&gt;
            &lt;li data-tcontent="doggy"&gt;not false&lt;/li&gt;
            &lt;li data-tcontent="not:doggy"&gt;not false&lt;/li&gt;
            &lt;li data-tcontent="eq: number1 number100"&gt;not true&lt;/li&gt;
            &lt;li data-tcontent="user.name | string:no friends"&gt;any friends?&lt;/li&gt;
            &lt;li data-tcontent="user2.name | string:no friends"&gt;any friends?&lt;/li&gt;
            &lt;li data-tcontent="items[0]"&gt;an item&lt;/li&gt;
            &lt;li data-tcontent="user/age()"&gt;user/age()&lt;/li&gt;
        &lt;/ol&gt;
    &lt;/body&gt;
&lt;/html&gt;

    </pre>
    The invokation of ZPT-JS is at:
    <pre>
jspt.run( document.body, dictionary );
    </pre>
    The first argument sets the DOM node where JPST will search its custom HTML tags. The second one
    is the dictionary, a Javascript object that will be available to all custom HTML tags of ZPT-JS.
    </p>
  </body>
</html>
     
