<!DOCTYPE html>
<html lang="en">

<head>
    <title>Zenon Page Templates (ZPT-JS): User's guide</title>
    <meta charset="UTF-8">
    <style>
        body {
            background-color: white;
            font-size: 12pt;
            color: black;
            font-family: arial, helvetica, verdana;
        }
        
        h1 {
            font-size: 24pt;
            font-weight: bold;
        }
        
        h2 {
            font-size: 20pt;
            font-weight: bold;
        }
        
        h3 {
            font-size: 18pt;
            font-weight: bold;
        }
        
        h4 {
            font-size: 16pt;
            font-weight: bold;
        }
        
        table,
        th,
        td {
            border: 1px solid black;
        }
        
        .sub {
            font-size: 10pt;
        }
        
        code {
            color: red;
        }
        
        pre {
            background-color: black;
            color: white;
            padding-top: 1em;
            padding-left: 4em;
        }
    </style>
</head>

<body>
    <a id="top"></a>
    <h1>Zenon Page Templates (ZPT-JS): User's guide</h1>
    <div class="sub">last modified: 2016/15/11</div>
    <div class="sub">author <a href="mailto:david.javapagetemplates@gmail.com">David Cana</a></div>
    <div class="sub">contributed by <a href="mailto:david.javapagetemplates@gmail.com">David Cana</a></div>

    <a id="zpt"></a>
    <h2>Zope Page Templates</h2>
    <p>
        ZPT-JS is a Javascript implementation of Zope Page Templates (ZPT). Because ZPT-JS isn't running in the context of Zope and isn't written with Python, there are necessarily some differences between ZPT-JS and ZPT. This document will concentrate on the ways that ZPT-JS differs from ZPT. For an introduction to ZPT refer to the chapter
        <a href="http://docs.zope.org/zope2/zope2book/ZPT.html">Using
      Zope Page Templates</a> in the
        <a href="http://docs.zope.org/zope2/zope2book/">Zope Book</a>. For a complete reference to ZPT, refer to the
        <a href="http://docs.zope.org/zope2/zope2book/AppendixC.html">ZPT Reference</a>.
    </p>
    
    <a id="firstSteps"></a>
    <h2>First steps using ZPT-JS</h2>
    <p>
        How can we use ZPT-JS? The <code>dictionary</code> is used to define global variables.
    </p>
    <p>
        An example of invoking ZPT-JS using require:
    </p>
    
    <strong>sample.js</strong>
    <pre>
"use strict";

var $ = require( 'jquery' );
var zpt = require( 'zpt' );

var dictionary = { 
    aString: "string",
    doggy: false,
    number1: 1,
    number100: 100,
    user: {
        name: "Bob", 
        age: function( ){
            return 25;
        }
    },
    items: [ 'item0', 'item1', 'item2' ]
};
    
zpt.run({
    root: document.body,
    dictionary: dictionary
});
    </pre>
    <p>
        Then browserify that file to build the final js file. And the html file is:
    </p>
    
    <strong>sample.html</strong>
    <pre>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;Some ZPT-JS examples&lt;/title&gt;
        
        &lt;script src="sample.js" defer&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Some expressions&lt;/h1&gt;
        &lt;ol&gt;
            &lt;li data-tcontent="user/name"&gt;xxx&lt;/li&gt;
            &lt;li data-tcontent="string:help my ${user/name}"&gt;xxx&lt;/li&gt;
            &lt;li data-tcontent="doggy"&gt;not false&lt;/li&gt;
            &lt;li data-tcontent="not:doggy"&gt;not false&lt;/li&gt;
            &lt;li data-tcontent="eq: number1 number100"&gt;not true&lt;/li&gt;
            &lt;li data-tcontent="user/name | string:no friends"&gt;any friends?&lt;/li&gt;
            &lt;li data-tcontent="user2/name | string:no friends"&gt;any friends?&lt;/li&gt;
            &lt;li data-tcontent="items[0]"&gt;an item&lt;/li&gt;
            &lt;li data-tcontent="user/age()"&gt;user/age()&lt;/li&gt;
        &lt;/ol&gt;
    &lt;/body&gt;
&lt;/html&gt;
    </pre>
    <p>
        The invokation of ZPT-JS is at:
    </p>
    <pre>
zpt.run({
    root: document.body,
    dictionary: dictionary
});
    </pre>
    <p>
        The first argument sets the DOM node where ZPT-JS will search its custom HTML tags. The second one is the dictionary, a Javascript object that will be available to all custom HTML tags of ZPT-JS. You can also run ZPT-JS as a Jquery plugin:
    </p>
    <pre>
$( 'body' ).zpt({
    dictionary: dictionary
});
    </pre>

    <a id="zpt.tags"></a>
    <h3>ZPT-JS tags</h3>
    <p>
        The name of tags are not the same because if they were the resulting HTML douments will not be well formed. The list of tags with their equivalences are:
    </p>
    <table>
        <tr>
            <th>ZPT tag name</th>
            <th>ZPT-JS tag name</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>metal:define-macro</td>
            <td>data-mdefine-macro</td>
            <td>Defines a macro</td>
        </tr>
        <tr>
            <td>metal:define-slot</td>
            <td>data-mdefine-slot</td>
            <td>Defines a slot to make possible to fill it later</td>
        </tr>
        <tr>
            <td>metal:fill-slot</td>
            <td>data-mfill-slot</td>
            <td>Fills a slot</td>
        </tr>
        <tr>
            <td>metal:use-macro</td>
            <td>data-muse-macro</td>
            <td>Invokes a macro</td>
        </tr>
        <tr>
            <td>tal:attributes</td>
            <td>data-tattributes</td>
            <td>Replace the value of one or more attributes</td>
        </tr>
        <tr>
            <td>tal:condition</td>
            <td>data-tcondition</td>
            <td>Display or hide nodes depending on a condition</td>
        </tr>
        <tr>
            <td>tal:content</td>
            <td>data-tcontent</td>
            <td>Replace the content of the element</td>
        </tr>
        <tr>
            <td>tal:define</td>
            <td>data-tdefine</td>
            <td>Define one or more variables</td>
        </tr>
        <tr>
            <td>tal:on-error</td>
            <td>data-ton-error</td>
            <td>Handle errors</td>
        </tr>
        <tr>
            <td>tal:omit-tag</td>
            <td>data-tomit-tag</td>
            <td>Remove an element, leaving the content of the element</td>
        </tr>
        <tr>
            <td>tal:repeat</td>
            <td>data-trepeat</td>
            <td>Repeat an element</td>
        </tr>
        <tr>
            <td>tal:replace</td>
            <td>data-treplace</td>
            <td>Replace the content of an element and remove the element leaving the content</td>
        </tr>
    </table>
    <p>
        The tags can be changed. Customize the <code>defaultTag</code> variable in <code>js/app/context.js</code> file. You can also use <code>context.setTags( tags )</code> to define the tags programmatically.
        <br> Important: <strong>after this point we will refer to tags as the ZPT-JS tag name</strong>.
    </p>

    <a id="zpt.evaluationOrder"></a>
    <h3>Evaluation order</h3>
    <p>
        The order evaluation of attributes in ZPT-JS is not equal than ZPT's. The new order is:
    </p>
    <ol>
        <li><code>data-trepeat</code></li>
        <li><code>data-ton-error</code></li>
        <li><code>data-mdefine-macro</code></li>
        <li><code>data-tdefine</code></li>
        <li><code>data-tcondition</code></li>
        <li><code>data-tomit-tag</code></li>
        <li><code>data-treplace</code></li>
        <li><code>data-tattributes</code></li>
        <li><code>data-tcontent</code></li>
        <li>content</li>
        <li><code>data-muse-macro</code></li>
    </ol>

    <a id="tales"></a>

    <a id="tales.path"></a>
    <h3>Path Expressions</h3>
    <p>
        The first element in a path expression must be a variable, a method call, a function call or a literal.
    </p>

    <a id="tales.path.literals"></a>
    <h4>Literals</h4>
    <p>
        Integer, float and boolean literals are defined in the same way as in the Javascript language. String literals are delimited by single quotes. Some example literals:
    </p>
    <ul>
        <li><code>9</code> (integer literal)</li>
        <li><code>9.0</code> (floating point literal)</li>
        <li><code>true</code> (boolean literal)</li>
        <li><code>'foobar'</code> (string literal)</li>
    </ul>

    <a id="tales.variables"></a>
    <h4>Variables</h4>
    <p>
        A variable is either predefined, defined via a <code>data-tdefine</code> attribute, or passed in to the template at runtime. The following variables are predefined:
    </p>
    <ul>
        <li><code>repeat</code> see <code><a href="https://docs.zope.org/zope2/zope2book/AppendixC.html#repeat-repeat-an-element">ZPT reference</a></code></li>
    </ul>
    <p>
        The <code>here</code> variable (the context) is not defined in ZPT-JS; it is implicit. The scope of all variables in dictionary is global. Take a look to <a href="#invocation">Invoking ZPT-JS</a> to understand how you can define variables of the dictionary.
        <br /> 
        The scope of the variables defined via a <code>data-tdefine</code> attribute is local. An example:
    </p>
    <pre>
&lt;div data-tdefine="a number"&gt;
    &lt;span data-treplace="a">5&lt;/span&gt;
&lt;/div&gt;
&lt;span data-treplace="a">null&lt;/span&gt;
    </pre>
    <p>
    At the first replace the value in <code>number</code> will be used. At the second replace, a <code>null</code> value (the <code>a</code> variable is out of scope).
    <br /> 
    Global variables are also implemented. Their scope is all document after their definition:
    </p>
    <pre>
&lt;div data-tdefine="global a number"&gt;
    &lt;span data-treplace="a">5&lt;/span&gt;
&lt;/div&gt;
&lt;span data-treplace="a">5&lt;/span&gt;
    </pre>
    <p>
        The following variables are defined in ZPT but not in ZPT-JS:
        <code>here, template, resolver, options, CONTEXTS, root, container, request, user, modules</code>. The following variables are defined in ZPT but aren't yet implemented in ZPT-JS:
        <code>nothing, default, attrs</code>. If you need these, holler.
    </p>

    <a id="tales.path.traversal"></a>
    <h4>Path traversal</h4>
    <p>
        Following the initial path element, path elements are either properties or methods of the preceding object. Examples:
    </p>
    <ul>
        <li><code>object/name</code> will search for a property <code>name</code> in the passed object.</li>
        <li><code>object/name()</code> will search for a method <code>name()</code> in the passed object.</li>
        <li><code>object/name( arg1, arg2 )</code> will search for a method <code>name()</code> in the passed object and pass <code>arg1</code> and <code>arg2</code> as parameters.</li>
        <li><code>object/name()/name2()</code> will search for a method <code>name()</code> in the passed object and then search for a method <code>name2()</code>.</li>
    </ul>
    <p>
        The last element in a path expression may resolve to <code>null</code>, but if an intermediate element resolves to <code>null</code> an <code>Exception</code> will be thrown.
    </p>

    <a id="tales.path.arrays"></a>
    <h4>Arrays</h4>
    <p>
        Array members may be accessed using the same syntax as in Javascript. Any number of dimensions are supported. The expression inside the array accessor may be any TALES expression and must evaluate to an integer value. If an array accessor is found modifying an object that is not an array an exception is thrown.
    </p>
    <ul>
        <li><code>people[ 2 ]</code></li>
        <li><code>people[ index ]</code></li>
    </ul>

    <a id="tales.javascript"></a>
    <h3>Javascript expressions</h3>
    <p>
        Javascript expressions work just like Python expressions in ZPT except that the Javascript language is used instead of Python. Any legal Javascript expression may be evaluated. Some examples:
    </p>
    <ul>
        <li><code>js: 4 + 5</code> returns the int 9</li>
        <li><code>js: ${aNumber} + 1</code> returns the result of adding 1 to the value of <code>aNumber</code> variable.</li>
    </ul>

    <a id="tales.exists"></a>
    <h3>Exists expressions</h3>
    <p>
        It evaluates as a boolean expression. If the expression is any of the next:
    </p>
    <ul>
        <li><code>undefined</code></li>
        <li><code>null</code></li>
        <li><code>'false'</code></li>
        <li><code>false</code></li>
        <li><code>0</code></li>
    </ul>
    <p>
        the expression evaluates to <code>false</code>. Otherwise the expression evaluates to <code>true</code>. If an exception is thrown trying to evaluate the expression, it evaluates to <code>false</code>.
    </p>

    <a id="tales.not"></a>
    <h3>Not expressions</h3>
    <p>
        Not expressions work more or less like in ZPT. The expression to which <code>not:</code> is applied must first be cast to a boolean. The result is then negated.
    </p>

    <a id="tales.math"></a>
    <h3>Math expressions</h3>
    <p>
        You can do some math operations using this expressions:
    </p>
    <ul>
        <li><code>+: x y</code> -> add x and y</li>
        <li><code>-: x y</code> -> subtract y from x</li>
        <li><code>*: x y</code> -> multiply x and y</li>
        <li><code>:: x y</code> -> divide x by y</li>
        <li><code>%: x y</code> -> x mod y</li>
    </ul>
    <p>
        In all cases, <code>x</code> and <code>y</code> are assumed integers. You can use more than 2 values to operate. You can use parenthesis. Some examples:
    </p>
    <ul>
        <li><code>-: assets liabilities</code></li>
        <li><code>*: 2 children</code></li>
        <li><code>+: 1 number1 number2</code></li>
        <li><code>+: 1 ( *: number1 number2 )</code></li>
    </ul>

    <a id="tales.bool"></a>
    <h3>Boolean expressions</h3>
    <p>
        The list of available boolean expressions are:
    </p>
    <ul>
        <li><code>or: x y</code> -> boolean or of expressions x and y</li>
        <li><code>and: x y</code> -> boolean and of expressions x and y</li>
        <li><code>cond: x y z</code> -> evaluate as boolean x; if true return y, otherwise return z</li>
    </ul>
    <p>
        All operators uses lazy evaluation. OR and AND expressions support 2 or more operators. COND expression only support 3. An example:
    </p>
    <ul>
        <li><code>&lt;p data-tcondition="and: ( exists:pets()/dog() ) ( not:pets()/dog()/badDog() )"&gt;
              Good Dog&lt;/p&gt;</code></li>
        <li><code>&lt;p data-tcondition="or: isFridayNight isSaturday isSunday"&gt;
              Yeah!&lt;/p&gt;</code></li>
        <li><code>&lt;p data-tcontent="cond: isFridayNight 'Yeah!' 'Oh!'"&gt;
              What?&lt;/p&gt;</code></li>
    </ul>

    <a id="tales.comparison"></a>
    <h3>Comparison expressions</h3>
    <p>
        The 3 available comparison expressions are:
    </p>
    <ul>
        <li><code>equals:</code> Checks if 2 or more integers are equals. If the values are not numbers, it checks if they are equals.</li>
        <li><code>greater:</code> Checks if a number is greater than another.</li>
        <li><code>lower:</code> Checks if a number is lower than another.</li>
    </ul>
    <p>
        Some examples:
    </p>
    <ul>
        <li><code>equals: assets liabilities anObject</code></li>
        <li><code>greater: 10 ( +: children pets )</code></li>
    </ul>

    <a id="tales.jquery"></a>
    <h3>Jquery expressions</h3>
    <p>
        ZPT-JS supports some jquery expressions:
    </p>

    <pre>
&lt;div&gt;
    &lt;div&gt;value1 = &lt;span id="value1" class="values"&gt;10&lt;/span&gt;&lt;/div&gt;
    &lt;div&gt;value2 = &lt;span id="value2" class="values"&gt;20&lt;/span&gt;&lt;/div&gt;
    &lt;div&gt;value3 = &lt;span id="value3" class="values"&gt;30&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;div data-tcontent="$('#value1')"&gt;must be 10&lt;/div&gt;
    &lt;div data-tcontent="$('.values')"&gt;must be 10,20,30&lt;/div&gt;
    &lt;div data-tcontent="+: $('.values')"&gt;must be 10 + 20 + 30 = 60&lt;/div&gt;
    &lt;div data-tcontent="+: 100 $( '.values' )"&gt;must be 100 + 10 + 20 + 30 = 160&lt;/div&gt;
&lt;/div&gt;
    </pre>

    <a id="tales.other"></a>
    <h3>Other expressions</h3>
    <p>
        String expressions behave exactly as in ZPT. Python expressions are not supported in ZPT-JS.
    </p>

    <a id="tal"></a>
    <h2>TAL Statements</h2>
    <p>
        All TAL statements behave almost exactly as in ZPT, except:
    </p>
    <ul>
        <li><code>tal:no-call</code>: not yet implemented</li>
        <li><code>data-tcondition</code> and <code>data-tomit-tag</code>: must cast their expression to a boolean, which follows the rules described for <a href="#tales.not">Not expressions</a>.</li>
        <li><code>data-treplace</code> and <code>data-tomit-tag</code>: because ZPT-JS modifies directly the template (ZPT generates a new document), these tags are REMOVED when they are not inside a macro definition. So if you update the dictionary a run ZPT-JS a second time these tags does not exist yet. If you need this to work place <code>data-treplace</code> and <code>data-tomit-tag</code> inside a macro definition and invoke it. See <a href="#metal">macros</a>.</li>
    </ul>

    <a id="tal.repeat"></a>
    <h3>Repeat expressions</h3>
    <p>
        There are a few minor variations for <code>tal:repeat</code>. The repeat expression must evaluate to an array.
    </p>

    <a id="tal.range"></a>
    <h3>Lists expressions</h3>
    <p>
        A list is defined as an enumeration of items in brackets. Some examples:
    </p>
    <ul>
        <li><code>[1 2 3]</code> evaluates as 1,2,3</li>
        <li><code>[1 2 3 number1]</code> evaluates as 1,2,3,1 (if the value of <code>number1</code> is 1)</li>
    </ul>
    <p>
        You can iterate through lists using loops:
    </p>
    <ul>
        <li><code>data-trepeat="c [10 20 30]"</code> iterates using <code>c</code> through 10, 20 and 30</li>
        <li><code>data-trepeat="mixed ['yes!' 'no!' aNumber]"</code> iterates using <code>mixed</code></li>
    </ul>
    <p>
        Another ways of using lists is as range expressions:
    </p>
    <ul>
        <li><code>data-trepeat="c [1:5]"</code> iterates using <code>c</code> through 1,2,3,4 and 5</li>
        <li><code>data-trepeat="c [1:7:2]"</code> iterates using <code>c</code> through 1,3,5 and 7</li>
        <li><code>data-trepeat="c [:5]"</code> iterates using <code>c</code> through 0,1,2,3,4 and 5</li>
    </ul>
    
    <p>
        Lists are very versatile:
    </p>
    <ul>
        <li><code>[1:3 10]</code> evaluates to 1,2,3 and 10</li>
        <li><code>[4 1:3 10]</code> evaluates to 4,1,2,3 and 10</li>
    </ul>
    
    <p>
        ...and can be used in arithmethic operations:
    </p>
    <ul>
        <li><code>+: [1:3 10]</code> evaluates to 1+2+3+10 = 16</li>
        <li><code>+: [4 1:3 10]</code> evaluates to 4+1+2+3+10 = 20</li>
    </ul>
    
    Don't forget to not use spaces inside ranges! 
    <ul>
        <li><code>[ 1 : 3 ]</code> will not work!</li>
    </ul>
    
    <a id="metal"></a>
    <h2>METAL</h2>
    <p>
        METAL statements behave exactly as in ZPT. The only difference, which is really a difference in Path expressions, is the means of finding another template which contains macros. There is no Zope tree in which to locate templates.
    </p>

    <a id="metal.local"></a>
    <h3>Local macros</h3>
    <p>
        Local macros are defined at the same HTML file where they are invoked. An example of definition of a local macro:
    </p>
    <pre>
&lt;ul data-mdefine-macro="list"&gt;
    &lt;li data-trepeat="item items"&gt;
        &lt;span data-tcontent="item"&gt;An item&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;
    </pre>
    <p>
        That macro generates an unordered list iterating through the <code>items</code> variable. Let's invoke them; to do this, the next HTML code must be at the same file.
    </p>
    <pre>
&lt;div data-tdefine="items [10 20 30]" data-muse-macro="list"&gt;
    Macro goes here
&lt;/div&gt;
    </pre>

    <a id="metal.external"></a>
    <h3>External macros</h3>
    <p>
        External macros are defined at a different page that where they are invoked. It only differs how they are invoked; if we want to invoke the macro <code>list</code> defined in <code>macros.html</code> file:
    </p>
    <pre>
&lt;div data-tdefine="items [10 20 30]" data-muse-macro="list/macros.html"&gt;
    Macro goes here
&lt;/div&gt;
    </pre>
    
    <a id="formatters"></a>
    <h2>Formatters</h2>
    <p>
        A <code>formatter</code> allows to format the evaluation of an expression. ZPT-JS includes some formatters:
    </p>
    <ul>
        <li><code>format: lowerCase 'Test'</code> evaluates as 'test'</li>
        <li><code>format: upperCase 'TEST'</code> evaluates as 'TEST'</li>
        <li><code>format: fix 1.371 2</code> evaluates as '1.37'</li>
        <li><code>format: fix (:: 1 3) 2</code> evaluates as '0.33'</li>
    </ul>
        
    <p>
        You can register other formatters of your own:
    </p>
    <pre>
context.registerFormatter( 
    'myCustomFormatter', 
    function( value ){
        return "$" + value;
    }
);
    </pre>
    <p>
        After registering it you will be able to use it as usual:
    </p>
    <ul>
        <li><code>format: myCustomFormatter aNumber</code></li>
    </ul>
    
    <p>
        It is possible to run custom formatters without registering them. They must be functions defined in the dictionary:
    </p>
    <ul>
        <li><code>format: customFormatter aNumber</code> formats aNumber using a function in the dictionary called <code>customFormatter</code></li>
        <li><code>format: customFormatterName aNumber</code> formats aNumber using a function in the dictionary called as the value of the <code>customFormatterName</code> variable</li>
    </ul>
    
    <a id="zpt.i18n"></a>
    <h3>I18n and l10n</h3>
    
    <h4>Basics about i18n</h4>
    <p>
        Nowadays ZPT-JS has some i18n capabilities. How do they work? Let's see an example:
    </p>
    
    <strong>i18n.js</strong>
    <pre>
"use strict";

var zpt = require( 'zpt' );

var msg = {
    en : {},
    es : {}
};

/* English i18n messages */
msg.en[ '/CONF/' ] = {
    language: 'en',
    locale: 'en-US'
};
msg.en[ 'Hello world!' ] = 'Hello world!';
msg.en[ 'Results msg' ] = '{GENDER, select, male{He} female{She} other{They} }' +
    ' found ' +
    '{RES, plural, =0{no results} one{1 result} other{# results} }';

/* Spanish i18n messages */
msg.es[ '/CONF/' ] = {
    language: 'es',
    locale: 'es-ES'
};
msg.es[ 'Hello world!' ] = '¡Hola mundo!';
msg.es[ 'Results msg' ] = '{ GENDER, select, male{Él} female{Ella} other{Ellos} }' +
    ' ' +
    '{ RES, plural, =0{no } other{} }' +
    '{ GENDER, select, male{ha} female{ha} other{han} }' +
    ' encontrado ' +
    '{ RES, plural, =0{ningún resultado} one{un único resultado} other{# resultados} }';

var dictionary = {
    'i18n-ES': new zpt.I18n( 'es', msg[ 'es' ] ),
    'i18n-EN': new zpt.I18n( 'en', msg[ 'en' ] )
};

// Parse template
zpt.run({
    root: document.body,
    dictionary: dictionary
});
    </pre>
    
    <strong>i18n.html</strong>
    <pre>
&lt;!DOCTYPE html&gt;
&lt;html lang="es"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;Some I18n examples&lt;/title&gt;
        
        &lt;script src="i18n.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Some I18n expressions&lt;/h1&gt;
        &lt;ol data-idomain="i18n-ES"&gt;
            &lt;li&gt;
               ¡Hola mundo! = 
               &lt;span data-tcontent="tr: 'Hello world!'"&gt;Must be ¡Hola mundo!&lt;/span&gt;
            &lt;/li&gt;
            &lt;li&gt;
               Él ha encontrado 10 resultados = 
                &lt;span data-tcontent="tr: 'Results msg' ( GENDER 'male'; RES 10 )"&gt;Must be 'Él ha encontrado 10 resultados'&lt;/span&gt;
            &lt;/li&gt;
        &lt;/ol&gt;
    &lt;/body&gt;
&lt;/html&gt;
    </pre>
    
    <p>
        Some remarks about this:
    </p>
    <ul>
        <li>The dictionary must contain at least one instance per supported language of <code>ZPT.I18n</code> class. The constructor accepts 2 arguments; the first is the language of the messages and the second is a map (keys are the id of the messages and values the message themselves). The format of the messages must complain <a href="http://userguide.icu-project.org/formatparse/messages">ICU standards</a>.</li>
        <li>The <code>data-idomain</code> attribute defines the <code>ZPT.I18n</code> to use.</li>
        <li>The <code>tr</code> expression  evaluates an expression but then it searches that value into the messages.</li>
        <li>The expression <code>'Hello world!'</code> is a literal, but <code>'Results msg' ( GENDER 'male'; RES 10 )</code> is a little more complex:
            <ol>
                <li>The first item is the message id: <code>'Results msg'</code>.</li>
                <li>The rest are variables used to build the message: <code>GENDER 'male'</code> defines a <code>GENDER</code> variable with <code>'male'</code> as value.</li>
                <li><code>RES 10</code> defines a <code>RES</code> variable with <code>10</code> as value.</li>
            </ol>
        </li>
    </ul>
    
    <h4>Some examples</h4>
    <p>
        Some examples of i18n tags in action:
    </p>
    <ul>
        <li>
            <code>&lt;img src="image.png" data-tattributes="title tr: 'Hello world!'"&gt;</code> adds an i18n title to the image.
        </li>
        <li>
            <code>&lt;li data-tdefine="msg tr: 'Hello world!'"&gt;</code> defines a <code>msg</code> variable with the i18n message of <code>'Hello world!'</code>.
        </li>
        <li>
            <code>&lt;body data-ton-error="tr: 'Oh, noooo!'"&gt;</code> sets the i18n message of <code>'Oh, noooo!'</code> as the message to show if an error occurs.
        </li>
        <li><code>&lt;span data-treplace="tr: 'Hello world!'"&gt;</code> replaces the <code>span</code> tag by the i18n message of <code>'Hello world!'</code>.</li>
    </ul>
    
    <h4>Working with domains</h4>
    <p>
        In the previous example the domain was a simple <code>ZPT.I18n</code> instance. This forces to use a big map with all the messages. This can be awful if the amount of messages is big. <code>data-idomain</code> tag supports also a list of <code>ZPT.I18n</code> instances, so the messages will be searched in the same order.
    </p>
    <p>
        Therefore, <code>data-idomain="i18n-ES1 i18n-ES2"</code> allows to organise your i18n messages in 2 maps. The first one can contain general messages and the second one more particular messages (for example).
    </p>
    
    <p>
        <code>data-idomain</code> also supports nested definitions:
    </p>
    <pre>
&lt;div data-idomain="i18n-ES1"&gt;
   &lt;span data-tcontent="tr: 'Hello world!'"&gt;
        ¡Hola mundo!
   &lt;/span&gt;
   &lt;span data-idomain="i18n-ES2" data-tcontent="tr: 'Hello world!'"&gt;
        ¡¡¡Hola mundo 2!!!
   &lt;/span&gt;
&lt;/div&gt; 
    </pre>
    <p>
        The first <code>data-tcontent</code> will search only in <code>i18n-ES1</code>. The second one will search first in <code>i18n-ES2</code> and if it is not found will search in <code>i18n-ES1</code>.
    </p>
    
    <h4>Loading messages from JSON files</h4>
    <p>
        ZPT-JS makes it easy loading i18n messages from JSON files:
    </p>
    <pre>
"use strict";

var zpt = require( 'zpt' );

var esJSONFileName = 'i18n/es1.json';
var enJSONFileName = 'i18n/en1.json';

var jsonFiles = [ esJSONFileName , enJSONFileName ];

zpt.i18nHelper.loadAsync( jsonFiles , callback );

function callback( i18nMap ){
    
    var dictionary = {
        'i18n-ES' : new zpt.I18n( 'es', i18nMap[ esJSONFileName ] ),
        'i18n-EN' : new zpt.I18n( 'en', i18nMap[ enJSONFileName ] )
    };
    
    zpt.run({
        root: document.body,
        dictionary: dictionary
    });
}
    </pre>
    
    <h4>Numbers</h4>
    <p>
        ZPT-JS uses <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Intl">Intl</a> as i18n API for numbers. Let's see some examples:
    </p>
    <ul>
        <li>
            <code>&lt;span data-tcontent="trNumber: 1355.23"&gt;</code> formats that number depending on the active i18n domain (<em>1,355.23</em> in english, <em>1.355,23</em> in spanish...).
        </li>
        <li>
            <code>&lt;span data-tcontent="trNumber: 1355.23643 ( maximumFractionDigits 3 )"&gt;</code> formats that number depending on the active i18n domain and using a maximum of 3 fraction digits (<em>1,355.236</em> in english, <em>1.355,236</em> in spanish...).
        </li>
        <li>
            <code>&lt;span data-tcontent="trNumber: 1355.23643 ( maximumFractionDigits 3; minimumIntegerDigits 6 )"&gt;</code> formats that number depending on the active i18n domain and using a maximum of 3 fraction digits and a minimum of 6 integer digits (<em>001,355.236</em> in english, <em>001.355,236</em> in spanish...).
        </li>
    </ul>
    
    <p>
        Take a look on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat">NumberFormat options</a> to see all available options.
    </p>
    
    <h4>Currencies</h4>
    <p>
        ZPT-JS uses <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Intl">Intl</a> as i18n API for currencies. Let's see some examples:
    </p>
    <ul>
        <li>
            <code>&lt;span data-tcontent="trCurrency: 'EUR' 1355.23"&gt;</code> formats that number depending on the active i18n domain and using that currency (<em>€ 1,355.23</em> in english, <em>1.355,23 €</em> in spanish...).
        </li>
        <li>
            <code>&lt;span data-tcontent="trCurrency: 'USD' 1355.23 ( currencyDisplay 'name' )"&gt;</code> uses the name of the currency (<em>1,355.23 US dollars</em> in english, <em>1.355,23 € dólares estadounidenses</em> in spanish...).
        </li>
    </ul>
    
    <p>
        Options are the same as numbers (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat">NumberFormat options</a>) plus some specific options of currencies.
    </p>
    
    <h4>Dates and times</h4>
    <p>
        ZPT-JS uses <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Intl">Intl</a> as i18n API for date and times. Let's see some examples:
    </p>
    <ul>
        <li>
            <code>&lt;span data-tcontent="trDate: ( js: new Date( Date.UTC( 2012, 11, 21, 3, 0, 0 ) ) )"&gt;</code> formats that date depending on the active i18n domain (<em>12/21/2012</em> in english, <em>21/12/2012</em> in spanish...).
        </li>
        <li>
            <code>&lt;span data-tcontent="trDate: ( js: new Date( Date.UTC( 2012, 11, 21, 3, 0, 0 ) ) ) (  weekday 'long'; year 'numeric'; month 'long'; day 'numeric' )"&gt;</code> formats that date with some options (<em>Friday, December 21, 2012</em> in english, <em>viernes, 21 de diciembre de 2012</em> in spanish...).
        </li>
        <li>
            <code>&lt;span data-tcontent="trDate: ( js: new Date( Date.UTC( 2012, 11, 21, 3, 0, 0 ) ) ) ( hour 'numeric'; minute 'numeric';  second 'numeric' )"&gt;</code> formats that date with some options (<em>4:00:00 AM</em> in english, <em>4:00:00</em> in spanish...).
        </li>
    </ul>
    
    <p>
        Take a look on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat">DateTimeFormat options</a> to see all available options.
    </p>
    
    <a id="zpt.grunt"></a>
    <h3>Building and testing</h3>
    <p>
        ZPT-JS uses <a href="http://gruntjs.com/">Grunt</a> as task runner tool. If you want to modify and rebuild ZPT-JS the next command lines are useful:
    </p>
    <pre>
$ grunt browserify // Build all test js files; also build a standalone version
$ grunt browserify:[file] // Build a single js file; use 'standalone' to build a standalone version
$ npm run server   // Run a beefy server to make it easy to test ZPT-JS without browserifying by hand
$ grunt compress   // Compress files and folders of this project into dist/zpt_yyyy-mm-dd_hhmm.tar.gz
    </pre>
    <p>
        ZPT-JS uses <a href="https://qunitjs.com/">QUnit</a> as testing framework. For testing ZPT-JS open test/index.html with your favourite browser.
    </p>
    
    <a id="moreExamples"></a>
    <h2>More examples</h2>
    <p>
        Please, take a look to test files in <code>test/</code> to view more ZPT-JS examples.
    </p>
</body>

</html>